{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/DSM20221/jikwan/github/RECOIL/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"/Users/DSM20221/jikwan/github/RECOIL/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.recoilPersist = void 0;\n/**\n * Recoil module to persist state to storage\n *\n * @param config Optional configuration object\n * @param config.key Used as key in local storage, defaults to `recoil-persist`\n * @param config.storage Local storage to use, defaults to `localStorage`\n */\n\nvar recoilPersist = function recoilPersist() {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  if (typeof window === 'undefined') {\n    return {\n      persistAtom: function persistAtom() {}\n    };\n  }\n\n  var _config$key = config.key,\n      key = _config$key === void 0 ? 'recoil-persist' : _config$key,\n      _config$storage = config.storage,\n      storage = _config$storage === void 0 ? localStorage : _config$storage;\n\n  var persistAtom = function persistAtom(_ref) {\n    var onSet = _ref.onSet,\n        node = _ref.node,\n        trigger = _ref.trigger,\n        setSelf = _ref.setSelf;\n\n    if (trigger === 'get') {\n      var state = getState();\n\n      if (typeof state.then === 'function') {\n        state.then(function (s) {\n          if (s.hasOwnProperty(node.key)) {\n            setSelf(s[node.key]);\n          }\n        });\n      }\n\n      if (state.hasOwnProperty(node.key)) {\n        setSelf(state[node.key]);\n      }\n    }\n\n    onSet( /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(newValue, _, isReset) {\n        var state;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                state = getState();\n\n                if (typeof state.then === 'function') {\n                  state.then(function (s) {\n                    return updateState(newValue, s, node.key, isReset);\n                  });\n                } else {\n                  updateState(newValue, state, node.key, isReset);\n                }\n\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      return function (_x, _x2, _x3) {\n        return _ref2.apply(this, arguments);\n      };\n    }());\n  };\n\n  var updateState = function updateState(newValue, state, key, isReset) {\n    if (isReset) {\n      delete state[key];\n    } else {\n      state[key] = newValue;\n    }\n\n    setState(state);\n  };\n\n  var getState = function getState() {\n    var toParse = storage.getItem(key);\n\n    if (toParse === null || toParse === undefined) {\n      return {};\n    }\n\n    if (typeof toParse === 'string') {\n      return parseState(toParse);\n    }\n\n    if (typeof toParse.then === 'function') {\n      return toParse.then(parseState);\n    }\n\n    return {};\n  };\n\n  var parseState = function parseState(state) {\n    if (state === undefined) {\n      return {};\n    }\n\n    try {\n      return JSON.parse(state);\n    } catch (e) {\n      console.error(e);\n      return {};\n    }\n  };\n\n  var setState = function setState(state) {\n    try {\n      if (typeof storage.mergeItem === 'function') {\n        storage.mergeItem(key, JSON.stringify(state));\n      } else {\n        storage.setItem(key, JSON.stringify(state));\n      }\n    } catch (e) {\n      console.error(e);\n    }\n  };\n\n  return {\n    persistAtom: persistAtom\n  };\n};\n\nexports.recoilPersist = recoilPersist;","map":{"version":3,"names":["Object","defineProperty","exports","value","recoilPersist","config","window","persistAtom","key","storage","localStorage","onSet","node","trigger","setSelf","state","getState","then","s","hasOwnProperty","newValue","_","isReset","updateState","setState","toParse","getItem","undefined","parseState","JSON","parse","e","console","error","mergeItem","stringify","setItem"],"sources":["/Users/DSM20221/jikwan/github/RECOIL/node_modules/recoil-persist/dist/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.recoilPersist = void 0;\n/**\n * Recoil module to persist state to storage\n *\n * @param config Optional configuration object\n * @param config.key Used as key in local storage, defaults to `recoil-persist`\n * @param config.storage Local storage to use, defaults to `localStorage`\n */\nconst recoilPersist = (config = {}) => {\n    if (typeof window === 'undefined') {\n        return {\n            persistAtom: () => { },\n        };\n    }\n    const { key = 'recoil-persist', storage = localStorage } = config;\n    const persistAtom = ({ onSet, node, trigger, setSelf }) => {\n        if (trigger === 'get') {\n            const state = getState();\n            if (typeof state.then === 'function') {\n                state.then((s) => {\n                    if (s.hasOwnProperty(node.key)) {\n                        setSelf(s[node.key]);\n                    }\n                });\n            }\n            if (state.hasOwnProperty(node.key)) {\n                setSelf(state[node.key]);\n            }\n        }\n        onSet(async (newValue, _, isReset) => {\n            const state = getState();\n            if (typeof state.then === 'function') {\n                state.then((s) => updateState(newValue, s, node.key, isReset));\n            }\n            else {\n                updateState(newValue, state, node.key, isReset);\n            }\n        });\n    };\n    const updateState = (newValue, state, key, isReset) => {\n        if (isReset) {\n            delete state[key];\n        }\n        else {\n            state[key] = newValue;\n        }\n        setState(state);\n    };\n    const getState = () => {\n        const toParse = storage.getItem(key);\n        if (toParse === null || toParse === undefined) {\n            return {};\n        }\n        if (typeof toParse === 'string') {\n            return parseState(toParse);\n        }\n        if (typeof toParse.then === 'function') {\n            return toParse.then(parseState);\n        }\n        return {};\n    };\n    const parseState = (state) => {\n        if (state === undefined) {\n            return {};\n        }\n        try {\n            return JSON.parse(state);\n        }\n        catch (e) {\n            console.error(e);\n            return {};\n        }\n    };\n    const setState = (state) => {\n        try {\n            if (typeof storage.mergeItem === 'function') {\n                storage.mergeItem(key, JSON.stringify(state));\n            }\n            else {\n                storage.setItem(key, JSON.stringify(state));\n            }\n        }\n        catch (e) {\n            console.error(e);\n        }\n    };\n    return { persistAtom };\n};\nexports.recoilPersist = recoilPersist;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}